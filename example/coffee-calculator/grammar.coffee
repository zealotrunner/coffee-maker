# The CoffeeLang parser is generated by [Jison](http://github.com/zaach/jison)
# from this grammar file. Jison is a bottom-up parser generator, similar in
# style to [Bison](http://www.gnu.org/software/bison), implemented in JavaScript.
# It can recognize [LALR(1), LR(0), SLR(1), and LR(1)](http://en.wikipedia.org/wiki/LR_grammar)
# type grammars. To create the Jison parser, we list the pattern to match
# on the left-hand side, and the action to take (usually the creation of syntax
# tree nodes) on the right. As the parser runs, it
# shifts tokens from our token stream, from left to right, and
# [attempts to match](http://en.wikipedia.org/wiki/Bottom-up_parsing)
# the token sequence against the rules below. When a match can be made, it
# reduces into the [nonterminal](http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)
# (the enclosing name at the top), and we proceed from there.
#
# If you run the `cake build:parser` command, Jison constructs a parse table
# from our rules and saves it into `lib/parser.js`.

# The only dependency is on the **Jison.Parser**.
{Parser} = require 'jison'

# Jison DSL
# ---------

# Since we're going to be wrapped in a function by Jison in any case, if our
# action immediately returns a value, we can optimize by removing the function
# wrapper and just returning the value directly.
unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/

# Our handy DSL for Jison grammar generation, For every rule in the grammar,
# we pass the pattern-defining string, the action to run, and extra options,
# optionally. If no action is specified, we simply pass the value of the
# previous nonterminal.
o = (patternString, action, options) ->
  patternString = patternString.replace /\s{2,}/g, ' '
  return [patternString, '$$ = $1;', options] unless action
  action = if match = unwrap.exec action then match[1] else "(#{action}())"
  action = action.replace /\bnew /g, '$&yy.'
  [patternString, "$$ = #{action};", options]

# Grammatical Rules
# -----------------

# In all of the rules that follow, you'll see the name of the nonterminal as
# the key to a list of alternative matches. With each match's action, the
# dollar-sign variables are provided by Jison as references to the value of
# their numeric position, so in this rule:
#
#     "Expression UNLESS Expression"
#
# `$1` would be the value of the first `Expression`, `$2` would be the token
# for the `UNLESS` terminal, and `$3` would be the value of the second
# `Expression`.
grammar =

  # The **Root** is the top-level node in the syntax tree. Since we parse bottom-up,
  # all parsing must end here.
  Root: [
    o ''
    o 'Calculator',                     -> new Calculator $1.value
  ]

  Calculator: [
    o 'Expression',                     -> new Expression $1.value
  ]

  Expression: [
    o 'Expression + Expression',        -> new Expression "#{$1.value} + #{$3.value}"
    o 'Expression - Expression',        -> new Expression "#{$1.value} - #{$3.value}"
    o 'Expression * Expression',        -> new Expression "#{$1.value} * #{$3.value}"
    o 'Expression / Expression',        -> new Expression "#{$1.value} / #{$3.value}"
    o 'Expression ^ Expression',        -> new Expression "Math.pow(#{$1.value}, #{$3.value})"
    o 'Expression %',                   -> new Expression "#{$1.value} / 100"
    o '- Expression',                  (-> new Expression "(-#{$2.value})", prec: 'UMINUS')
    o '+ Expression',                  (-> new Expression "(+#{$2.value})", prec: 'UPLUS')
    o '( Expression )',                 -> new Expression "(#{$2.value})"
    o 'NUMBER',                         -> new Expression "#{$1}"
    o 'CONSTANT',                       -> new Expression "Math.#{$1}"
  ]

# Precedence
# ----------

# Operators at the top of this list have higher precedence than the ones lower
# down. Following these rules is what makes `2 + 3 * 4` parse as:
#
#     2 + (3 * 4)
#
# And not:
#
#     (2 + 3) * 4
operators = [
  ['left', '+', '-']
  ['left', '*', '/']
  ['left', '%' ]
  ['left', '^' ]
  ['left', 'UMINUS', 'UPLUS']
]

# Wrapping Up
# -----------

# Finally, now that we have our **grammar** and our **operators**, we can create
# our **Jison.Parser**. We do this by processing all of our rules, recording all
# terminals (every symbol which does not appear as the name of a rule above)
# as "tokens".
tokens = []
for name, alternatives of grammar
  grammar[name] = for alt in alternatives
    for token in alt[0].split ' '
      tokens.push token unless grammar[token]
    alt[1] = "return #{alt[1]}" if name is 'Root'
    alt

# Initialize the **Parser** with our list of terminal **tokens**, our **grammar**
# rules, and the name of the root.
exports.parser = new Parser
  tokens      : tokens.join ' '
  bnf         : grammar
  operators   : operators
  startSymbol : 'Root'
