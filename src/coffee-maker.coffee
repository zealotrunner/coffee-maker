# CoffeeMaker is derived from CoffeeScript, as a command-line compiler toolkit
# based on Node.js/V8, This module contains the main entry functions for
# tokenizing, parsing, and compiling source CoffeeLang into TargetLang.

fs   = require 'fs'
path = require 'path'
vm   = require 'vm'
bean = require './i'

exports.helpers   = require './helpers'

{lexer, parser, evalc} = bean

exports.compile = compile = bean.compile
exports.tokens  = bean.tokens
exports.nodes   = bean.nodes
exports.run     = bean.run

exports.REPL_PROMPT              = bean.COMMAND + '> '
exports.REPL_PROMPT_MULTILINE    = Array(bean.COMMAND.length + 1).join('-') + '> '
exports.REPL_PROMPT_CONTINUATION = Array(bean.COMMAND.length + 1).join('.') + '> '

# The current CoffeeMaker version number.
exports.MAKER_VERSION    = MAKER_VERSION = '0.1.0'

exports.BEAN_VERSION     = BEAN_VERSION = bean.VERSION

exports.COFFEE_NAME      = COFFEE_NAME = bean.NAME
exports.COFFEE_COMMAND   = bean.COMMAND
exports.COFFEE_EXTENSION = COFFEE_EXTENSION = bean.EXTENSION
exports.TARGET_EXTENSION = bean.TARGET_EXTENSION

# Words that cannot be used as identifiers in CoffeeLang code
exports.RESERVED        = bean.RESERVED or []
#
exports.COFFEE_SWITCHES = bean.COMMAND_SWITCHES or []

stripBOM = (content) ->
  if content.charCodeAt(0) is 0xFEFF then content.substring 1 else content

# TODO: Remove registerExtension when fully deprecated.
if require.extensions
  require.extensions[COFFEE_EXTENSION] = (module, filename) ->
    content = compile stripBOM(fs.readFileSync filename, 'utf8'), {filename}
    module._compile content, filename
else if require.registerExtension
  require.registerExtension COFFEE_EXTENSION, (content) -> compile content

# Compile a string of CoffeeLang code to TargetLang, using the Coffee/Jison
# compiler.
exports.compile = compile = (code, options = {}) ->
  try
    tcode = (parser.parse lexer.tokenize code).compile options
    return tcode unless options.header
  catch err
    err.message = "In #{options.filename}, #{err.message}" if options.filename
    throw err
  header = "Generated by #{COFFEE_NAME} #{BEAN_VERSION}. Powered by CoffeeMaker #{MAKER_VERSION}"
  "// #{header}\n#{tcode}"

# Tokenize a string of CoffeeLang code, and return the array of tokens.
exports.tokens = (code, options) ->
  lexer.tokenize code, options

# Parse a string of CoffeeLang code or an array of lexed tokens, and
# return the AST. You can then compile it by calling `.compile()` on the root,
# or traverse it by using `.traverseChildren()` with a callback.
exports.nodes = (source, options) ->
  if typeof source is 'string'
    parser.parse lexer.tokenize source, options
  else
    parser.parse source

# Compile and execute a string of CoffeeLang (on the server), correctly
# setting `__filename`, `__dirname`, and relative `require()`.
exports.run = (code, options = {}) ->
  mainModule = require.main

  # Set the filename.
  mainModule.filename = process.argv[1] =
      if options.filename then fs.realpathSync(options.filename) else '.'

  # Clear the module cache.
  mainModule.moduleCache and= {}

  # Assign paths for node_modules loading
  mainModule.paths = require('module')._nodeModulePaths path.dirname fs.realpathSync options.filename

  # Compile.
  if path.extname(mainModule.filename) isnt '.coffee' or require.extensions
    mainModule._compile compile(code, options), mainModule.filename
  else
    mainModule._compile code, mainModule.filename

# Compile and evaluate a string of CoffeeLang (in a Node.js-like environment).
# The CoffeeLang REPL uses this to run the input.
exports.eval = (code, options = {}) ->
  return unless code = code.trim()

  Script = vm.Script
  if Script
    if options.sandbox?
      if options.sandbox instanceof Script.createContext().constructor
        sandbox = options.sandbox
      else
        sandbox = Script.createContext()
        sandbox[k] = v for own k, v of options.sandbox
      sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox
    else
      sandbox = global
    sandbox.__filename = options.filename || 'eval'
    sandbox.__dirname  = path.dirname sandbox.__filename
    # define module/require only if they chose not to specify their own
    unless sandbox isnt global or sandbox.module or sandbox.require
      Module = require 'module'
      sandbox.module  = _module  = new Module(options.modulename || 'eval')
      sandbox.require = _require = (path) ->  Module._load path, _module, true
      _module.filename = sandbox.__filename
      _require[r] = require[r] for r in Object.getOwnPropertyNames require when r isnt 'paths'
      # use the same hack node currently uses for their own REPL
      _require.paths = _module.paths = Module._nodeModulePaths process.cwd()
      _require.resolve = (request) -> Module._resolveFilename request, _module

  o = {}
  o[k] = v for own k, v of options

  # TODO
  o.bare = on # ensure return value
  evalc compile(code, o), sandbox

